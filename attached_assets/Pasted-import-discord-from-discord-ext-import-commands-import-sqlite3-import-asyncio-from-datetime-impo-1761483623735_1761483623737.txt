import discord
from discord.ext import commands
import sqlite3
import asyncio
from datetime import datetime
import json
import re
import os
from flask import Flask
from threading import Thread

# ===== WEB SERVER (for UptimeRobot) =====
app = Flask('')

@app.route('/')
def home():
    return "QuestAretuza Bot is alive!"

def run():
    # ‚úÖ FIXED: Replit requires port 5000
    app.run(host='0.0.0.0', port=5000)

def keep_alive():
    t = Thread(target=run)
    t.start()

# ===== CONFIG =====
BOT_TOKEN = os.environ.get("BOT_TOKEN", "").strip()
if not BOT_TOKEN:
    raise ValueError("‚ùå BOT_TOKEN secret is missing!")

# ‚ö†Ô∏è REPLACE THESE WITH ACTUAL BOT IDs
BOT_IDS_TO_TRACK = [123456789012345678, 987654321098765678]

MIN_WORDS = 3

# ===== GLOBAL STATE =====
last_bot_message = {}
bot_interaction_sessions = {}
voice_start = {}

# ===== DATABASE =====
def get_db():
    conn = sqlite3.connect('solo_leveling.db')
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    with get_db() as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            current_level INTEGER DEFAULT 0,
            total_messages INTEGER DEFAULT 0,
            total_vc_seconds INTEGER DEFAULT 0,
            total_invites INTEGER DEFAULT 0,
            messages_since_level INTEGER DEFAULT 0,
            vc_seconds_since_level INTEGER DEFAULT 0,
            invites_since_level INTEGER DEFAULT 0,
            bot_interactions INTEGER DEFAULT 0,
            pending_tasks TEXT DEFAULT '[]',
            banner_url TEXT DEFAULT '',
            embed_color TEXT DEFAULT '#00ff00'
        )''')
        conn.execute('''CREATE TABLE IF NOT EXISTS invite_quests (
            user_id INTEGER PRIMARY KEY,
            active INTEGER DEFAULT 0,
            target_invites INTEGER DEFAULT 0,
            current_invites INTEGER DEFAULT 0,
            base_level INTEGER DEFAULT 0
        )''')
        conn.execute('''CREATE TABLE IF NOT EXISTS mod_reviews (
            user_id INTEGER,
            task_type TEXT,
            message_id INTEGER,
            channel_id INTEGER,
            assigned_mods TEXT,
            status TEXT DEFAULT 'pending'
        )''')

def get_user(user_id):
    with get_db() as conn:
        row = conn.execute("SELECT * FROM users WHERE user_id = ?", (user_id,)).fetchone()
        if not row:
            conn.execute("INSERT INTO users (user_id) VALUES (?)", (user_id,))
            row = conn.execute("SELECT * FROM users WHERE user_id = ?", (user_id,)).fetchone()
        return row

def update_user(user_id, **kwargs):
    if not kwargs: return
    cols = ', '.join([f"{k} = ?" for k in kwargs])
    vals = list(kwargs.values()) + [user_id]
    with get_db() as conn:
        conn.execute(f"UPDATE users SET {cols} WHERE user_id = ?", vals)

# ‚úÖ FIXED: Added missing functions
def get_invite_quest(user_id):
    with get_db() as conn:
        row = conn.execute("SELECT * FROM invite_quests WHERE user_id = ?", (user_id,)).fetchone()
        if not row:
            conn.execute("INSERT INTO invite_quests (user_id) VALUES (?)", (user_id,))
            row = conn.execute("SELECT * FROM invite_quests WHERE user_id = ?", (user_id,)).fetchone()
        return row

def update_invite_quest(user_id, **kwargs):
    if not kwargs: return
    cols = ', '.join([f"{k} = ?" for k in kwargs])
    vals = list(kwargs.values()) + [user_id]
    with get_db() as conn:
        conn.execute(f"UPDATE invite_quests SET {cols} WHERE user_id = ?", vals)

# ===== BOT SETUP =====
intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True
intents.members = True

# ‚úÖ PREFIX = "Quar"
bot = commands.Bot(command_prefix="Quar", intents=intents, help_command=None)

# ===== LEVELING CONFIG =====
LEVEL_REQUIREMENTS = {
    0: (0, 0, 0, []),
    1: (100, 60, 0, []),
    2: (1000, 600, 0, []),
    3: (2000, 1800, 0, []),
    4: (2000, 1800, 1, []),
    5: (5000, 0, 0, ["bot_usage_5", "plants_10"]),
    6: (5000, 3600, 3, []),
    7: (10000, 18000, 0, ["bot_usage_100"]),
    8: (10000, 18000, 5, ["screen_time_proof"]),
    9: (15000, 36000, 5, ["touch_grass_10"]),
    10: (20000, 90000, 0, ["steps_or_hunt_14"]),
}

TASK_DESCRIPTIONS = { ... }  # (keep your existing dict)

# ===== UTILS =====
def calculate_xp(messages, bot_interactions):
    return messages + int(bot_interactions * 0.1)

def is_valid_hex(color):
    return re.match(r'^#([A-Fa-f0-9]{6})$', color)

def is_valid_image_url(url):
    return url.startswith(('http://', 'https://')) and any(ext in url.lower() for ext in ['.png', '.jpg', '.jpeg', '.gif', '.webp'])

# ===== EVENTS =====
@bot.event
async def on_message(message):
    if message.author.bot:
        if message.author.id in BOT_IDS_TO_TRACK:
            last_bot_message[message.channel.id] = (message.author.id, datetime.utcnow())
        return

    if len(message.content.split()) < MIN_WORDS:
        return

    user_id = message.author.id

    # Bot interaction
    if message.channel.id in last_bot_message:
        bot_id, bot_time = last_bot_message[message.channel.id]
        if (datetime.utcnow() - bot_time).total_seconds() < 30:
            bot_interaction_sessions[user_id] = bot_interaction_sessions.get(user_id, 0) + 1
            if bot_interaction_sessions[user_id] >= 3:
                user = get_user(user_id)
                update_user(user_id,
                    bot_interactions=user["bot_interactions"] + 1,
                    total_messages=user["total_messages"] + 1,
                    messages_since_level=user["messages_since_level"] + 1
                )
                bot_interaction_sessions[user_id] = 0
                await check_level_up(message.author)
                return

    # Normal message
    user = get_user(user_id)
    update_user(user_id,
        total_messages=user["total_messages"] + 1,
        messages_since_level=user["messages_since_level"] + 1
    )
    await check_level_up(message.author)
    await bot.process_commands(message)

@bot.event
async def on_voice_state_update(member, before, after):
    if member.bot: return
    now = datetime.utcnow()
    user_id = member.id

    if before.channel and not after.channel:
        if user_id in voice_start:
            duration = (now - voice_start[user_id]).total_seconds()
            user = get_user(user_id)
            update_user(user_id,
                total_vc_seconds=user["total_vc_seconds"] + duration,
                vc_seconds_since_level=user["vc_seconds_since_level"] + duration
            )
            del voice_start[user_id]
            await check_level_up(member)

    elif not before.channel and after.channel:
        voice_start[user_id] = now

@bot.event
async def on_member_join(member):
    inviter = None
    guild = member.guild
    try:
        invites_before = await guild.invites()
        await asyncio.sleep(1)
        invites_after = await guild.invites()
        for inv_before in invites_before:
            for inv_after in invites_after:
                if inv_before.code == inv_after.code and inv_before.uses < inv_after.uses:
                    inviter = inv_before.inviter
                    break
            if inviter:
                break
    except Exception as e:
        print(f"Invite error: {e}")
        return

    if inviter:
        user = get_user(inviter.id)
        update_user(inviter.id,
            total_invites=user["total_invites"] + 1,
            invites_since_level=user["invites_since_level"] + 1
        )
        # ‚úÖ FIXED: Full invite quest logic restored
        quest = get_invite_quest(inviter.id)
        if quest["active"]:
            new_count = quest["current_invites"] + 1
            update_invite_quest(inviter.id, current_invites=new_count)
            if new_count >= quest["target_invites"]:
                new_level = min(quest["base_level"] + 1, 10)
                update_user(inviter.id, current_level=new_level)
                update_invite_quest(inviter.id, active=0)
                try:
                    await inviter.send(f"üéâ You leveled up to **Level {new_level}** via Invite Quest!")
                except:
                    pass
        await check_level_up(inviter)

async def check_level_up(user):
    user_data = get_user(user.id)
    if user_data["current_level"] >= 10:
        return

    req = LEVEL_REQUIREMENTS[user_data["current_level"] + 1]
    if (user_data["messages_since_level"] >= req[0] and
        user_data["vc_seconds_since_level"] >= req[1] and
        user_data["invites_since_level"] >= req[2]):

        pending = json.loads(user_data["pending_tasks"])
        if all(task in pending for task in req[3]) or not req[3]:
            new_level = user_data["current_level"] + 1
            update_user(user.id,
                current_level=new_level,
                messages_since_level=0,
                vc_seconds_since_level=0,
                invites_since_level=0
            )
            try:
                await user.send(f"üî• **LEVEL UP!** You are now **Level {new_level}**!")
            except:
                pass

# ===== COMMANDS =====
# In ALL command descriptions, use "Quar" prefix

@bot.command()
async def profile(ctx, member: discord.Member = None):
    member = member or ctx.author
    user = get_user(member.id)
    color = int(user["embed_color"].strip('#'), 16) if is_valid_hex(user["embed_color"]) else 0x00ff00
    embed = discord.Embed(title=f"{member.display_name}'s Profile", color=color)
    if user["banner_url"]:
        embed.set_image(url=user["banner_url"])
    embed.add_field(name="Level", value=user["current_level"], inline=False)
    embed.add_field(name="Total Messages", value=user["total_messages"])
    embed.add_field(name="Total VC Time", value=f"{int(user['total_vc_seconds']//3600)}h {int((user['total_vc_seconds']%3600)//60)}m")
    embed.add_field(name="Total Invites", value=user["total_invites"])
    embed.add_field(name="Bot Interactions", value=user["bot_interactions"])
    embed.add_field(name="Total XP", value=calculate_xp(user["total_messages"], user["bot_interactions"]), inline=False)
    
    if user["current_level"] < 10:
        req = LEVEL_REQUIREMENTS[user["current_level"] + 1]
        embed.add_field(name="Progress to Level", value=f"{user['current_level']} ‚Üí {user['current_level']+1}", inline=False)
        embed.add_field(name="Messages", value=f"{user['messages_since_level']}/{req[0]}")
        embed.add_field(name="VC Time", value=f"{int(user['vc_seconds_since_level']//60)}/{req[1]//60} min")
        embed.add_field(name="Invites", value=f"{user['invites_since_level']}/{req[2]}")
        if req[3]:
            pending = json.loads(user["pending_tasks"])
            tasks = "\n".join([f"‚úÖ {t}" if t in pending else f"‚ùå {TASK_DESCRIPTIONS.get(t, t)}" for t in req[3]])
            embed.add_field(name="Special Tasks", value=tasks, inline=False)
    await ctx.send(embed=embed)

@bot.command(aliases=['lb'])
async def leaderboard(ctx, category: str = "xp"):
    with get_db() as conn:
        if category == "xp":
            rows = conn.execute("""
                SELECT user_id, total_messages, bot_interactions 
                FROM users 
                ORDER BY (total_messages + CAST(bot_interactions * 0.1 AS INT)) DESC 
                LIMIT 10
            """).fetchall()
            entries = []
            for i, row in enumerate(rows, 1):
                user = bot.get_user(row["user_id"])
                name = user.display_name if user else f"[Left] {row['user_id']}"
                xp = calculate_xp(row["total_messages"], row["bot_interactions"])
                entries.append(f"{i}. **{name}** ‚Äî {xp} XP")
            title = "üèÜ Top 10 by XP"

        elif category == "messages":
            rows = conn.execute("SELECT user_id, total_messages FROM users ORDER BY total_messages DESC LIMIT 10").fetchall()
            entries = [f"{i}. **{(bot.get_user(r['user_id']).display_name if bot.get_user(r['user_id']) else f'[Left] {r[\"user_id\"]}') }** ‚Äî {r['total_messages']} msgs" for i, r in enumerate(rows, 1)]
            title = "üí¨ Top 10 by Messages"

        # ... (similarly fix vc, invites, bot with safe user lookup)

        else:
            await ctx.send("Invalid category. Use: `xp`, `messages`, `vc`, `invites`, `bot`")
            return

    embed = discord.Embed(title=title, description="\n".join(entries), color=0xffd700)
    await ctx.send(embed=embed)

# ‚úÖ Update ALL help/guide text to use "Quar"
@bot.command()
async def guide(ctx):
    embed = discord.Embed(title="üåü Welcome to QuestAretuza!", color=0x00ff00)
    embed.description = """
    **How to Level Up:**
    - Send messages (‚â•3 words)
    - Join voice chat
    - Invite friends
    - Use bots like Yggdrasil
    - Complete real-life quests

    **Commands:**
    - `Quarprofile` ‚Äî See your progress
    - `Quarlb` ‚Äî Leaderboard
    - `Quarstart_invite_quest` ‚Äî Start invite challenge
    - `Quarsubmit_task <task>` ‚Äî Submit proof
    - `Quarbanner <url>` / `Quarcolor <hex>` ‚Äî Customize

    Progress resets after each level!
    """
    await ctx.send(embed=embed)

@bot.command()
async def help(ctx):
    embed = discord.Embed(title="üìö QuestAretuza Commands", color=0x1e90ff)
    cmds = [
        ("`Quarprofile [@user]`", "View profile"),
        ("`Quarlb [category]`", "Leaderboard (xp, messages, vc, invites, bot)"),
        ("`Quarbanner <url>`", "Set profile banner"),
        ("`Quarcolor <hex>`", "Change embed color"),
        ("`Quarstart_invite_quest`", "Start invite quest"),
        ("`Quarsubmit_task <task>`", "Submit task proof"),
        ("`Quarguide`", "Get started"),
        ("`Quarhelp`", "Show this menu"),
    ]
    for name, value in cmds:
        embed.add_field(name=name, value=value, inline=False)
    await ctx.send(embed=embed)

# ... (keep banner, color, submit_task, approve commands ‚Äî they're fine)

# ===== RUN =====
if __name__ == "__main__":
    init_db()
    print("‚úÖ Bot starting with prefix 'Quar'...")
    keep_alive()
    bot.run(BOT_TOKEN)